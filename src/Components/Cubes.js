/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import { Instances, Instance, Float } from '@react-three/drei'
import * as THREE from 'three'
import { useState, useMemo, useRef, useEffect } from 'react'
import { useThree } from '@react-three/fiber'
import { LayerMaterial, Depth, Fresnel } from 'lamina/vanilla'

const object = new THREE.Object3D()
const colorA = new THREE.Color('#FFA500').convertSRGBToLinear()
const colorB = new THREE.Color('#880000').convertSRGBToLinear()
const fresnel = new THREE.Color('#ffffff').convertSRGBToLinear()
const material = new LayerMaterial({
  layers: [
    new Depth({
      colorA: colorA,
      colorB: colorB,
      alpha: 0.5,
      mode: 'normal',
      near: 0,
      far: 2,
      origin: [1, 1, 1]
    }),
    new Depth({
      colorA: 'orange',
      colorB: colorB,
      alpha: 0.5,
      mode: 'add',
      near: 3,
      far: 2,
      origin: [1, 1, 1]
    }),
    new Fresnel({
      mode: 'add',
      color: fresnel,
      intensity: 1,
      power: 2.5,
      bias: 0.0
    })
  ]
})

function CubeInstance({ id, object, ...props }) {
  const ref = useRef()
  const { viewport, camera } = useThree()
  const [speed] = useState(() => 0.1 + Math.random() / 10)
  const scale = useMemo(() => {
    const s = Math.random() / 1.5
    return [s, s, s]
  }, [])

  const position = useMemo(() => {
    const z = (Math.random() + 5) * -1
    const bounds = viewport.getCurrentViewport(camera, [0, 0, z])
    return [THREE.MathUtils.randFloatSpread(bounds.width), THREE.MathUtils.randFloatSpread(bounds.height * 0.75), z]
  }, [viewport, camera])

  return (
    <group {...props}>
      <Float position={position} scale={scale} speed={speed} rotationIntensity={25} floatIntensity={25} dispose={null}>
        <Instance ref={ref} />
      </Float>
    </group>
  )
}

function CubeInstances({ count, objects }) {
  return (
    <group>
      <Instances range={count} material={material}>
        <extrudeBufferGeometry />
        {objects.map((obj, i) => (
          <CubeInstance key={i} id={i} object={obj} />
        ))}
      </Instances>
    </group>
  )
}

const Cubes = ({ count = 100 }) => {
  const objects = useMemo(() => Array.from({ length: count }).map(() => object), [count])
  const [trees, setTrees] = useState([])

  useEffect(() => {
    setTrees(objects)
  }, [objects])

  return (
    <group position={[0, 0, 0]}>
      <CubeInstances objects={trees} count={count} />
    </group>
  )
}

export { Cubes }
